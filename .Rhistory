RefQ <- "Dec-17" #reference quarter for WTP values
EstQ <- "Dec-24" #estimates quarter for overall costs
CPI <- getCPI(RefQ)[EstQ,"Cumm.Inflation.Multiplier"]
checkMissingCodes <- function(field, datacodes, action = stop){
UsedCodes <- map(c(PathogenAssumptions, SequelaeAssumptions), ~.x[[field]])
UsedCodesUnlist <- UsedCodes %>% unlist %>% unique
AllCodes <- datacodes %>% unique
MissingCodes <- setdiff(UsedCodesUnlist, AllCodes)
if(length(MissingCodes)){
message <- paste0('Some of the ', field, ' required by the model are missing from the data :\n   ',
paste(MissingCodes, collapse = '\n   '))
## Flag T/F if all data for a disease is missing. True if the disease has
## any codes listed BUT none of these codes are in the data. I.e. does not
## flag a problem for GBS for which we have not listed or used the hosp
## codes (because we assume all cases are hospitalised)
MissingDiseases <- map(UsedCodes,~{
PresentCodes <- intersect(.x, AllCodes)
!length(PresentCodes) & length(.x)
}) %>% unlist()
if(any(MissingDiseases)){
message <- paste0('Some diseases are missing all ', field, ' :\n   ',
paste(names(MissingDiseases)[MissingDiseases], collapse = '\n   '),
'\n', message)
}
action(message)
}
}
checkSurplusCodes <- function(field, datacodes, action = stop){
UsedCodes <- map(c(PathogenAssumptions, SequelaeAssumptions), ~.x[[field]])
AllCodes <- datacodes %>% unique
SurplusCodes <- setdiff(AllCodes,UsedCodes)
if(length(SurplusCodes)){
action('Some of the ', field, ' provided in the data are not used in the model:\n   ',
paste(SurplusCodes, collapse = '\n   '))
}
}
checkMissingCodes('mortCodes', Deaths$Cause, action = stop)
checkSurplusCodes('mortCodes', Deaths$Cause, action = warning)
#This second check is perhaps not needed for the hospitalisation data, as this
#dataset only has rows if there are any hospitalisations recorded (there are no
#rows with zero separations). If the model finds no rows it already interprets
#as no separations, so perhaps we need a separate check to see if input codes
#are valid in the future
checkMissingCodes('hospCodes', Hospitalisations$DC4D, action = warning)
checkMissingCodes('hospCodes',
subset(Hospitalisations, Year == "2022-23")$DC4D,
action = warning)
# Draw from all distributions
ndraws <- 10^5
set.seed(20250605) #Date at time of last run
WTPList <- getWTP(ndraws) %>%
map_depth(2,~{.x * CPI}) #adjust costs from 2017 dollars to present
IncidenceList <- makeIncidenceList(year = 'most_recent', # This uses the most recent NNDSS notifications extracted above from the /Data folder
pathogens = PathogenAssumptions,
ndraws = ndraws,
gastroRate = gastroRate)
SequelaeFractions <- calcSequelaeFractions(IncidenceList)
HospList <- makeHospList(year = 'most_recent', # This uses the most recent AIHW separations extracted above from the /Data folder
IncidenceList,
pathogens = PathogenAssumptions,
ndraws = ndraws)
warnings()
DeathList <- makeDeathList(year = 2024,  # This uses ABS population data for the year of choice to population adjust ABS-death data (averaged over a decade) to the year of choice
pathogens = PathogenAssumptions,
ndraws = ndraws)
CostList <- makeCostList(year = 'most_recent', # this uses the most recent NNDSS notification data (for certain costs that are only for notifications and not for all cases) and the most recent AHIW hospitalisation data (to estimate the LOS to determine time off work)
PathogenAssumptions,
ndraws,
discount = 0) # no discounting and assuming a 5 year duration of ongoing illness is equivalent to the cross-sectional approach if we assume that case numbers were the same over the past five years.
appendSequelaeToAllGastro <- function(List, .f){
List$`All gastro pathogens` <- c(List$`All gastro pathogens`,
imap(SequelaeAssumptions, #re-nest list with sequelae above pathogens and dropping initial diseases
function(.s,.sn){
map(List,~.x[[.sn]])
}) %>%
map(~{.x[!unlist(map(.x,is.null))]}) %>% #drop pathogens with no sequelae
map(~do.call(.f,unname(.x)))) #sum over pathogens by sequelae
List
}
CostList <- appendSequelaeToAllGastro(CostList,add2)
HospList <- appendSequelaeToAllGastro(HospList,add)
DeathList <- appendSequelaeToAllGastro(DeathList,add)
IncidenceList <- appendSequelaeToAllGastro(IncidenceList,add)
### Create a new category called all pathogens (which includes all pathogens, not just those that cause gastro)
appendAllPathogens <- function(List, .f){
List$`All pathogens`<- c(list(Initial = .f(List$`All gastro pathogens`$Gastroenteritis,
List$`Salmonella Typhi`$`Typhoid Fever`,
List$`Toxoplasma gondii`$Toxoplasmosis,
List$`Listeria monocytogenes`$Listeriosis)),
List$`All gastro pathogens`[names(List$`All gastro pathogens`) != 'Gastroenteritis']
)
List
}
CostList <- appendAllPathogens(CostList,add2)
HospList <- appendAllPathogens(HospList,add)
DeathList <- appendAllPathogens(DeathList,add)
IncidenceList <- appendAllPathogens(IncidenceList,add)
warning('When summing across agegroups the draws of the multipliers used for each agegroup are considered independent. Making them dependent would require reworking the whole program, and is not necessarily a better assumption, but it is something to be aware of')
#Include `All ages` and `All diseases` sums, calculate median, and 90 CIs, then reformat as data.frame
summariseEpiList <- function(list){
list %>%
map_depth(2,~{.x$`All ages` <- reduce(.x,`+`);.x}) %>%
map(~{.x$`Initial and sequel disease` <- do.call(add,unname(.x));.x}) %>%
quantilesNestedList(3, c("Pathogen", "Disease","AgeGroup"))
}
# Include `All ages` and `All diseases` sums, calculate median, and 90 CIs, then
# reformat as data.frame. Outputs are returned in categorised format (Deaths,
# Human Captial, Direct, WTP) or detailed (Tests, Medications, Hospitalisation...)
summariseCostList <- function(list){
#Add totals for `All ages` and `All diseases` (aka initial and sequel diseases)
totals <- list %>%
map_depth(2,~{.x$`All ages` <- do.call(add,unname(.x));.x}) %>%
map(~{.x$`Initial and sequel disease` <- do.call(add2,unname(.x));.x})
Detailed <- totals %>% quantilesNestedList(4, c("Pathogen", "Disease","AgeGroup","CostItem"))
DirectCat <- c('GPSpecialist','ED','Hospitalisation','Tests','Medications')
WTPCat <- c('WTP', 'WTPOngoing')
LostProdCat <- c("HumanCapital","FrictionHigh", "FrictionLow")
Categorised <- totals %>%
map_depth(3,~{
.x$Direct <- reduce(.x[DirectCat],`+`) #sum over direct costs
.x$WTP <- reduce(.x[WTPCat],`+`) #sum of WTP and WTP-onging
.x <- .x[c("Deaths",LostProdCat, paste0("Total",LostProdCat),"Direct","WTP")] #drop sub-categories
names(.x) <- c("Premature mortality", LostProdCat, paste0("Total",LostProdCat), 'Direct','Pain and suffering')
.x
}) %>%
quantilesNestedList(4, c("Pathogen", "Disease","AgeGroup","CostItem"))
list(Categorised = Categorised, Detailed = Detailed)
}
##### Calculate and store selected summaries ##################################
TotalCostByPathogen <- CostList %>%
map_depth(3,~.x$TotalHumanCapital) %>% #Extract out total cost (human capital method)
map_depth(2,~reduce(.x,`+`)) %>% #Sum over age groups
map_depth(1,~reduce(.x,`+`)) #Sum over diseases (initial and sequelae)
TotalIncidence <- IncidenceList %>%
map(~.x[[1]]) %>% #only consider initial infections (drop sequelae counts)
map_depth(1,~reduce(.x,`+`)) #sum over age groups
#Note this includes all sequelae for the purpose of counting costs, but only the initial cases for the purpose of counting cases.
CostPerCase <- map2(TotalCostByPathogen,TotalIncidence,~.x/.y) %>%
quantilesNestedList(1,"Pathogen")
write.csv(CostPerCase, './Outputs/CostPerCase.csv')
IncidenceTable <- summariseEpiList(IncidenceList)
HospTable <- summariseEpiList(HospList)
DeathTable <- summariseEpiList(DeathList)
EpiTable <- bind_rows(Deaths = DeathTable,
Hospitalisations = HospTable,
Cases = IncidenceTable,
.id = 'Measure')
write.csv(EpiTable,'./Outputs/EpiTable.csv')
CostSummaries <- summariseCostList(CostList)
write.csv(CostSummaries$Detailed,'./Outputs/CostTable.csv')
write.csv(CostSummaries$Categorised,'./Outputs/CostTableCategories.csv')
# save workspace in two versions; one light version to be used by the shiny app
# and another larger version with everything
save.image('AusFBDiseaseImage.RData')
gc()
UnusedLargeObjects <- c('CostList','SequelaeFractions','TotalCostByPathogen',
'TotalIncidence')
#trim DeathList, HospList, and IncidenceList down to 1000 draws
trim <- 1000
DeathList <- DeathList %>% map_depth(3,~.x[1:trim])
HospList <- HospList %>% map_depth(3,~.x[1:trim])
IncidenceList <- IncidenceList %>% map_depth(3,~.x[1:trim])
WTPList <- WTPList %>% map_depth(2,~.x[1:trim])
Hospitalisations <- subset(Hospitalisations,
DC4D %in% (map(c(PathogenAssumptions,
SequelaeAssumptions),
~.x$hospCodes) %>%
unlist(use.names = F) %>% unique))
save(list = setdiff(ls(all.names = T), UnusedLargeObjects),
file = 'Outputs/AusFBDiseaseImage-Light.RData')
shiny::runApp()
DiseaseAssumtions <- c(PathogenAssumptions, SequelaeAssumptions)
OldProps <- DiseaseAssumtions %>%
map(~.x$hospPrincipalDiagnosis$params$value)
names(OldProps) <- DiseaseAssumtions %>%
map(~.x$name)
OldProps %>%
unlist() %>%
data.frame(Prop = .) %>%
rownames_to_column(var = 'Descriptor') %>%
full_join(d.summary, by = 'Descriptor', suffix = c(".Old", ".New")) %>%
select(Descriptor, Prop.Old, Prop.New) %>%
View
d.summary <- d %>%
group_by(`ICD-10 code`, Descriptor, Kind) %>%
summarise(Count = sum(Count, na.rm = TRUE)) %>%
pivot_wider(names_from = Kind, values_from = Count) %>%
mutate(Prop = Principal/(Additional + Principal)) %>%
subset(Descriptor %in% KeyDiseases)
library(tidyverse)
#metadata to help read in data
meta <- data.frame(FY = 2019:2023, ## FY is the year of the end e.g. FY2019 is AKA 2018-19
StartRow = 4 + 28*(0:4), # First row for each FY block
EndRow = 28 + 28*(0:4)) %>% # Last  row for each FY block
cross_join(data.frame(Kind = c('Principal', 'Additional')))
# read in data
d <- meta %>%
group_by(FY, Kind) %>%
group_modify(~{
readxl::read_excel(path = "./NonPublicData/AH2024-0038 - Part A - Unprotected.xlsx",
sheet = paste(.y$Kind, 'diagnosis'),
range = readxl::cell_limits(ul = c(.x$StartRow,1),
lr = c(.x$EndRow, 16)))
}) %>%
# convert to long form for age groups
ungroup() %>%
pivot_longer(`Under 5`:`65 and older`,
names_to = 'Age', values_to = 'Count') %>%
# convert to numeric for counts, handling blanks
mutate(Count = as.numeric(na_if(Count, 'n.p.'))) %>%
# collapse down to preferred age-groups
mutate(Agegroup = case_match(Age,
"Under 5" ~ "<5",
"65 and older" ~ "65+",
.default = "5-64"
)) %>%
group_by(`ICD-10 code`, Descriptor, FY, Kind, Agegroup) %>%
summarise(Count = sum(Count)) %>%
ungroup()
# Add row for 'All gastro'
GastroDescriptors <- c("Salmonellosis", "Shigellosis", "Campylobacteriosis",
"Escherichia coli infection",
#"Gastroenteritis of unknown origin",
"STEC", "Yersiniosis", "Norovirus infection")
d <- d %>% subset(Descriptor %in% GastroDescriptors) %>%
mutate(Descriptor = 'Gastro (except unknown)',
`ICD-10 code` = 'Many') %>%
group_by(`ICD-10 code`,Descriptor,FY, Kind, Agegroup) %>%
summarise(Count = sum(Count,na.rm = TRUE)) %>%
bind_rows(d)
d <- d %>% subset(Descriptor %in% c(GastroDescriptors,"Gastroenteritis of unknown origin")) %>%
mutate(Descriptor = 'Gastro (including unknown)',
`ICD-10 code` = 'Many') %>%
group_by(`ICD-10 code`,Descriptor,FY, Kind, Agegroup) %>%
summarise(Count = sum(Count,na.rm = TRUE)) %>%
bind_rows(d)
KeyDiseases <- c(GastroDescriptors, "Gastroenteritis of unknown origin",
"Irritable Bowel Syndrome", "Toxoplasmosis", "Listeriosis",
"Reactive Arthritis",'Gastro (including unknown)',
'Gastro (except unknown)', "Typhoid fever")
# Calculate ratios by FY and agegroup
p <- d %>%
pivot_wider(names_from = Kind, values_from = Count) %>%
mutate(Prop = Principal/(Additional + Principal)) %>%
subset(Descriptor %in% KeyDiseases) %>%
ggplot(aes(x= FY, y=Prop, color = Descriptor)) +
geom_line() +
facet_wrap(~Agegroup)
plotly::ggplotly(p)
d %>%
group_by(`ICD-10 code`, Descriptor, Kind, Agegroup) %>%
summarise(Count = sum(Count, na.rm = TRUE)) %>%
pivot_wider(names_from = Kind, values_from = Count) %>%
mutate(Prop = Principal/(Additional + Principal))
# Calculate ratios by FY and across agegroup
p <- d %>%
group_by(`ICD-10 code`, Descriptor, Kind, FY) %>%
summarise(Count = sum(Count, na.rm = TRUE)) %>%
subset(Descriptor %in% KeyDiseases) %>%
pivot_wider(names_from = Kind, values_from = Count) %>%
mutate(Prop = Principal/(Additional + Principal)) %>%
ggplot(aes(x= FY, y=Prop, color = Descriptor)) +
geom_line()
plotly::ggplotly(p)
d.summary <- d %>%
group_by(`ICD-10 code`, Descriptor, Kind) %>%
summarise(Count = sum(Count, na.rm = TRUE)) %>%
pivot_wider(names_from = Kind, values_from = Count) %>%
mutate(Prop = Principal/(Additional + Principal)) %>%
subset(Descriptor %in% KeyDiseases)
View(d.summary)
source("./RFiles/Distributions.R")
source("./RFiles/ClassDefinitions.R")
source("./RFiles/Diseases.R")
DiseaseAssumtions <- c(PathogenAssumptions, SequelaeAssumptions)
OldProps <- DiseaseAssumtions %>%
map(~.x$hospPrincipalDiagnosis$params$value)
names(OldProps) <- DiseaseAssumtions %>%
map(~.x$name)
OldProps %>%
unlist() %>%
data.frame(Prop = .) %>%
rownames_to_column(var = 'Descriptor') %>%
full_join(d.summary, by = 'Descriptor', suffix = c(".Old", ".New")) %>%
select(Descriptor, Prop.Old, Prop.New) %>%
View
OldProps %>%
unlist() %>%
data.frame(Prop = .) %>%
rownames_to_column(var = 'Descriptor') %>%
full_join(d.summary, by = 'Descriptor', suffix = c(".Old", ".New")) %>%
select(Descriptor, Prop.Old, Prop.New) %>%
View
d
View(d)
View(d.summary)
runApp()
# Calculate ratios by FY and agegroup
p <- d %>%
pivot_wider(names_from = Kind, values_from = Count) %>%
mutate(Prop = Principal/(Additional + Principal)) %>%
subset(Descriptor %in% KeyDiseases) %>%
ggplot(aes(x= FY, y=Prop, color = Descriptor)) +
geom_line() +
facet_wrap(~Agegroup)
plotly::ggplotly(p)
Deaths
Deaths %>% subset(Cause == "A32")
source("./RFiles/loadData.R")
Deaths <- getABSDeaths()
Deaths <- getABSDeaths()
source("./RFiles/loadData.R")
Deaths <- getABSDeaths()
Deaths %>% subset(Cause == "A32")
gc()
gc()
gc()
gc()
library(tidyverse)
source("./RFiles/Distributions.R")
source("./RFiles/ClassDefinitions.R")
source("./RFiles/Diseases.R")
source("./RFiles/loadData.R")
source('./RFiles/summaryFunctions.R')
source("./RFiles/estimationFunctions.R")
### Load all the data and assumptions
NNDSSIncidenceAgegroup <- getCasesNNDSSAgeGroup() %>% subset(Disease != "STEC") #STEC is in the dataset, but quality of state surveillance deemed better.
StateIncidenceAgeGroup <- getCasesStateAgeGroup()
NotificationsAgeGroup <- bind_rows(NNDSSIncidenceAgegroup,StateIncidenceAgeGroup)
AusPopAgegroup <- getAusPopAgeGroup() #Population by year for the 3 broad age-groups
AusPopSingleYear <- getAusPopSingleYearAge() # Population by year for every age
Hospitalisations <- getHospitalisationsAgeGroup()
Costs <- getCosts()
VSL <- getValueStatisticalLife()
Deaths <- getABSDeaths()
MissedDaysGastro <- getMissedDaysGastro()
FrictionRates <- getFrictionRates()
Workforce <- getWorkforceAssumptions()
### CPI adjustment
#The only CPI adjustment is for WTP estimates for pain and suffering (values taken from CHERE report in 2017 dollars)
RefQ <- "Dec-17" #reference quarter for WTP values
EstQ <- "Dec-24" #estimates quarter for overall costs
CPI <- getCPI(RefQ)[EstQ,"Cumm.Inflation.Multiplier"]
checkMissingCodes <- function(field, datacodes, action = stop){
UsedCodes <- map(c(PathogenAssumptions, SequelaeAssumptions), ~.x[[field]])
UsedCodesUnlist <- UsedCodes %>% unlist %>% unique
AllCodes <- datacodes %>% unique
MissingCodes <- setdiff(UsedCodesUnlist, AllCodes)
if(length(MissingCodes)){
message <- paste0('Some of the ', field, ' required by the model are missing from the data :\n   ',
paste(MissingCodes, collapse = '\n   '))
## Flag T/F if all data for a disease is missing. True if the disease has
## any codes listed BUT none of these codes are in the data. I.e. does not
## flag a problem for GBS for which we have not listed or used the hosp
## codes (because we assume all cases are hospitalised)
MissingDiseases <- map(UsedCodes,~{
PresentCodes <- intersect(.x, AllCodes)
!length(PresentCodes) & length(.x)
}) %>% unlist()
if(any(MissingDiseases)){
message <- paste0('Some diseases are missing all ', field, ' :\n   ',
paste(names(MissingDiseases)[MissingDiseases], collapse = '\n   '),
'\n', message)
}
action(message)
}
}
checkSurplusCodes <- function(field, datacodes, action = stop){
UsedCodes <- map(c(PathogenAssumptions, SequelaeAssumptions), ~.x[[field]])
AllCodes <- datacodes %>% unique
SurplusCodes <- setdiff(AllCodes,UsedCodes)
if(length(SurplusCodes)){
action('Some of the ', field, ' provided in the data are not used in the model:\n   ',
paste(SurplusCodes, collapse = '\n   '))
}
}
checkMissingCodes('mortCodes', Deaths$Cause, action = stop)
checkSurplusCodes('mortCodes', Deaths$Cause, action = warning)
#This second check is perhaps not needed for the hospitalisation data, as this
#dataset only has rows if there are any hospitalisations recorded (there are no
#rows with zero separations). If the model finds no rows it already interprets
#as no separations, so perhaps we need a separate check to see if input codes
#are valid in the future
checkMissingCodes('hospCodes', Hospitalisations$DC4D, action = warning)
checkMissingCodes('hospCodes',
subset(Hospitalisations, Year == "2022-23")$DC4D,
action = warning)
# Draw from all distributions
ndraws <- 10^5
set.seed(20250605) #Date at time of last run
WTPList <- getWTP(ndraws) %>%
map_depth(2,~{.x * CPI}) #adjust costs from 2017 dollars to present
IncidenceList <- makeIncidenceList(year = 'most_recent', # This uses the most recent NNDSS notifications extracted above from the /Data folder
pathogens = PathogenAssumptions,
ndraws = ndraws,
gastroRate = gastroRate)
SequelaeFractions <- calcSequelaeFractions(IncidenceList)
HospList <- makeHospList(year = 'most_recent', # This uses the most recent AIHW separations extracted above from the /Data folder
IncidenceList,
pathogens = PathogenAssumptions,
ndraws = ndraws)
DeathList <- makeDeathList(year = 2024,  # This uses ABS population data for the year of choice to population adjust ABS-death data (averaged over a decade) to the year of choice
pathogens = PathogenAssumptions,
ndraws = ndraws)
CostList <- makeCostList(year = 'most_recent', # this uses the most recent NNDSS notification data (for certain costs that are only for notifications and not for all cases) and the most recent AHIW hospitalisation data (to estimate the LOS to determine time off work)
PathogenAssumptions,
ndraws,
discount = 0) # no discounting and assuming a 5 year duration of ongoing illness is equivalent to the cross-sectional approach if we assume that case numbers were the same over the past five years.
appendSequelaeToAllGastro <- function(List, .f){
List$`All gastro pathogens` <- c(List$`All gastro pathogens`,
imap(SequelaeAssumptions, #re-nest list with sequelae above pathogens and dropping initial diseases
function(.s,.sn){
map(List,~.x[[.sn]])
}) %>%
map(~{.x[!unlist(map(.x,is.null))]}) %>% #drop pathogens with no sequelae
map(~do.call(.f,unname(.x)))) #sum over pathogens by sequelae
List
}
CostList <- appendSequelaeToAllGastro(CostList,add2)
HospList <- appendSequelaeToAllGastro(HospList,add)
DeathList <- appendSequelaeToAllGastro(DeathList,add)
IncidenceList <- appendSequelaeToAllGastro(IncidenceList,add)
### Create a new category called all pathogens (which includes all pathogens, not just those that cause gastro)
appendAllPathogens <- function(List, .f){
List$`All pathogens`<- c(list(Initial = .f(List$`All gastro pathogens`$Gastroenteritis,
List$`Salmonella Typhi`$`Typhoid Fever`,
List$`Toxoplasma gondii`$Toxoplasmosis,
List$`Listeria monocytogenes`$Listeriosis)),
List$`All gastro pathogens`[names(List$`All gastro pathogens`) != 'Gastroenteritis']
)
List
}
CostList <- appendAllPathogens(CostList,add2)
HospList <- appendAllPathogens(HospList,add)
DeathList <- appendAllPathogens(DeathList,add)
IncidenceList <- appendAllPathogens(IncidenceList,add)
warning('When summing across agegroups the draws of the multipliers used for each agegroup are considered independent. Making them dependent would require reworking the whole program, and is not necessarily a better assumption, but it is something to be aware of')
#Include `All ages` and `All diseases` sums, calculate median, and 90 CIs, then reformat as data.frame
summariseEpiList <- function(list){
list %>%
map_depth(2,~{.x$`All ages` <- reduce(.x,`+`);.x}) %>%
map(~{.x$`Initial and sequel disease` <- do.call(add,unname(.x));.x}) %>%
quantilesNestedList(3, c("Pathogen", "Disease","AgeGroup"))
}
# Include `All ages` and `All diseases` sums, calculate median, and 90 CIs, then
# reformat as data.frame. Outputs are returned in categorised format (Deaths,
# Human Captial, Direct, WTP) or detailed (Tests, Medications, Hospitalisation...)
summariseCostList <- function(list){
#Add totals for `All ages` and `All diseases` (aka initial and sequel diseases)
totals <- list %>%
map_depth(2,~{.x$`All ages` <- do.call(add,unname(.x));.x}) %>%
map(~{.x$`Initial and sequel disease` <- do.call(add2,unname(.x));.x})
Detailed <- totals %>% quantilesNestedList(4, c("Pathogen", "Disease","AgeGroup","CostItem"))
DirectCat <- c('GPSpecialist','ED','Hospitalisation','Tests','Medications')
WTPCat <- c('WTP', 'WTPOngoing')
LostProdCat <- c("HumanCapital","FrictionHigh", "FrictionLow")
Categorised <- totals %>%
map_depth(3,~{
.x$Direct <- reduce(.x[DirectCat],`+`) #sum over direct costs
.x$WTP <- reduce(.x[WTPCat],`+`) #sum of WTP and WTP-onging
.x <- .x[c("Deaths",LostProdCat, paste0("Total",LostProdCat),"Direct","WTP")] #drop sub-categories
names(.x) <- c("Premature mortality", LostProdCat, paste0("Total",LostProdCat), 'Direct','Pain and suffering')
.x
}) %>%
quantilesNestedList(4, c("Pathogen", "Disease","AgeGroup","CostItem"))
list(Categorised = Categorised, Detailed = Detailed)
}
##### Calculate and store selected summaries ##################################
TotalCostByPathogen <- CostList %>%
map_depth(3,~.x$TotalHumanCapital) %>% #Extract out total cost (human capital method)
map_depth(2,~reduce(.x,`+`)) %>% #Sum over age groups
map_depth(1,~reduce(.x,`+`)) #Sum over diseases (initial and sequelae)
TotalIncidence <- IncidenceList %>%
map(~.x[[1]]) %>% #only consider initial infections (drop sequelae counts)
map_depth(1,~reduce(.x,`+`)) #sum over age groups
#Note this includes all sequelae for the purpose of counting costs, but only the initial cases for the purpose of counting cases.
CostPerCase <- map2(TotalCostByPathogen,TotalIncidence,~.x/.y) %>%
quantilesNestedList(1,"Pathogen")
write.csv(CostPerCase, './Outputs/CostPerCase.csv')
IncidenceTable <- summariseEpiList(IncidenceList)
HospTable <- summariseEpiList(HospList)
DeathTable <- summariseEpiList(DeathList)
EpiTable <- bind_rows(Deaths = DeathTable,
Hospitalisations = HospTable,
Cases = IncidenceTable,
.id = 'Measure')
write.csv(EpiTable,'./Outputs/EpiTable.csv')
CostSummaries <- summariseCostList(CostList)
write.csv(CostSummaries$Detailed,'./Outputs/CostTable.csv')
write.csv(CostSummaries$Categorised,'./Outputs/CostTableCategories.csv')
gc()
gc()
# save workspace in two versions; one light version to be used by the shiny app
# and another larger version with everything
save.image('AusFBDiseaseImage.RData')
UnusedLargeObjects <- c('CostList','SequelaeFractions','TotalCostByPathogen',
'TotalIncidence')
#trim DeathList, HospList, and IncidenceList down to 1000 draws
trim <- 1000
DeathList <- DeathList %>% map_depth(3,~.x[1:trim])
HospList <- HospList %>% map_depth(3,~.x[1:trim])
IncidenceList <- IncidenceList %>% map_depth(3,~.x[1:trim])
WTPList <- WTPList %>% map_depth(2,~.x[1:trim])
Hospitalisations <- subset(Hospitalisations,
DC4D %in% (map(c(PathogenAssumptions,
SequelaeAssumptions),
~.x$hospCodes) %>%
unlist(use.names = F) %>% unique))
save(list = setdiff(ls(all.names = T), UnusedLargeObjects),
file = 'Outputs/AusFBDiseaseImage-Light.RData')
runApp()
runApp()
