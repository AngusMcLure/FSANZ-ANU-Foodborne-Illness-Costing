if(.p$caseMethod == "Notifications"){
ntfcs <- subset(NotificationsAgeGroup,Disease == .p$name & Year == year & AgeGroup %in% ageGroups)
if(nrow(ntfcs) == 0)stop('No notifications available for for year ', year, ', disease ', .p$name)
else if(nrow(ntfcs) > length(ageGroups))stop('More than one number found for notifications for year ', year, ', disease ', .p$name)
notifications <- list(ntfcs$Cases)
names(notifications) <- ntfcs$AgeGroup
print(notifications)
} else notifications <- NULL
out <- estimateIncidence(.p,ndraws = ndraws, notifications = notifications,
population = subset(AusPopSingleYear, Year == year)$Persons,
gastroRate = gastroRate)
out <- list(out)
names(out) <- .p$name
out
})
Sequel <- map(pathogens,function(.p){
map(.p[["sequelae"]],function(.s){
map(ageGroups,function(.a){
draw(.s, ndraws) * Initial[[.p$pathogen]][[.p$name]][[.a]]
})
})
})
#combine
imap(pathogens, ~c(Initial[[.y]], Sequel[[.y]]))
}
estimateIncidence <- function(disease, ndraws = 10^6,
gastroRate = NULL, notifications = NULL,
population = NULL){
print(disease$name)
#abbreviate
d <- disease
n <- ndraws
ageGroups = c("<5","5-64","65+")
names(ageGroups) <- ageGroups
if(d$caseMethod == 'Notifications' && is.null(notifications)) stop("Notification numbers must be supplied for estimates from notifiable diseases")
draws <- switch(d$caseMethod,
Notifications = draw(d$underreporting, n) * draw(d$domestic, n),
GastroFraction = draw(gastroRate, n) * draw(d$gastroFraction, n),
Seroprevalence = draw(d$FOI, n))
foodborne <- draw(d$foodborne, n)
if(!is.null(d$symptomatic)){
symptomatic <- draw(d$symptomatic, n)
}else{
symptomatic <- 1
}
map(ageGroups, function(.a){
minAge <- switch(.a, `<5` = 0, `5-64` = 5,`65+` = 65)
maxAge <-  switch(.a, `<5` = 5, `5-64` = 65,`65+` = 101)
if(d$caseMethod != "Notifications") population <- population[(minAge+1):maxAge]
incidence <- switch(d$caseMethod,
Notifications = notifications[[.a]] * draws * foodborne * symptomatic,
GastroFraction = sum(population) * draws * foodborne * symptomatic,
Seroprevalence = {
as.numeric(map(draws,~{
S <- exp(-.x * (minAge:maxAge))
sum(population * (S[1:(maxAge-minAge)] - S[1+(1:(maxAge-minAge))]))
})) * symptomatic * foodborne
})
incidence
})
}
### CURRENTLY THE ESTIMATES COSTS FUNCTION PULLS ON INCIDENCE LIST AS A GLOBAL
### VARIABLE WITH NO REGARD FOR WHICH YEAR INCIDENCE LIST WAS CALCULATED FOR.
### I.E. YOU CAN CALCULATE INCIDENCE FOR YEAR 2019 THEN CALCULATE COSTS FOR YEAR
### 2020 WITHOUT GETTING AN ERROR. FIX BY MAKING INCIDENCE A LIST OF LISTS
### WITH AND ENTRY FOR EACH YEAR?
IncidenceList <- makeIncidenceList(2019,
pathogens = PathogenAssumptions,
ndraws = ndraws,
gastroRate = gastroRate)
makeIncidenceList <- function(year, pathogens, ndraws = 10^6, gastroRate){
ageGroups <- c("<5","5-64","65+")
names(ageGroups) <- ageGroups
Initial <- map(pathogens,
function(.p){
if(.p$caseMethod == "Notifications"){
ntfcs <- subset(NotificationsAgeGroup,Disease == .p$name & Year == year & AgeGroup %in% ageGroups)
if(nrow(ntfcs) == 0)stop('No notifications available for for year ', year, ', disease ', .p$name)
else if(nrow(ntfcs) > length(ageGroups))stop('More than one number found for notifications for year ', year, ', disease ', .p$name)
print(ntfcs)
notifications <- list(ntfcs$Cases)
names(notifications) <- ntfcs$AgeGroup
print(notifications)
} else notifications <- NULL
out <- estimateIncidence(.p,ndraws = ndraws, notifications = notifications,
population = subset(AusPopSingleYear, Year == year)$Persons,
gastroRate = gastroRate)
out <- list(out)
names(out) <- .p$name
out
})
Sequel <- map(pathogens,function(.p){
map(.p[["sequelae"]],function(.s){
map(ageGroups,function(.a){
draw(.s, ndraws) * Initial[[.p$pathogen]][[.p$name]][[.a]]
})
})
})
#combine
imap(pathogens, ~c(Initial[[.y]], Sequel[[.y]]))
}
### CURRENTLY THE ESTIMATES COSTS FUNCTION PULLS ON INCIDENCE LIST AS A GLOBAL
### VARIABLE WITH NO REGARD FOR WHICH YEAR INCIDENCE LIST WAS CALCULATED FOR.
### I.E. YOU CAN CALCULATE INCIDENCE FOR YEAR 2019 THEN CALCULATE COSTS FOR YEAR
### 2020 WITHOUT GETTING AN ERROR. FIX BY MAKING INCIDENCE A LIST OF LISTS
### WITH AND ENTRY FOR EACH YEAR?
IncidenceList <- makeIncidenceList(2019,
pathogens = PathogenAssumptions,
ndraws = ndraws,
gastroRate = gastroRate)
makeIncidenceList <- function(year, pathogens, ndraws = 10^6, gastroRate){
ageGroups <- c("<5","5-64","65+")
names(ageGroups) <- ageGroups
Initial <- map(pathogens,
function(.p){
if(.p$caseMethod == "Notifications"){
ntfcs <- subset(NotificationsAgeGroup,Disease == .p$name & Year == year & AgeGroup %in% ageGroups)
if(nrow(ntfcs) == 0)stop('No notifications available for for year ', year, ', disease ', .p$name)
else if(nrow(ntfcs) > length(ageGroups))stop('More than one number found for notifications for year ', year, ', disease ', .p$name)
print(ntfcs)
notifications <- as.list(ntfcs$Cases)
names(notifications) <- ntfcs$AgeGroup
print(notifications)
} else notifications <- NULL
out <- estimateIncidence(.p,ndraws = ndraws, notifications = notifications,
population = subset(AusPopSingleYear, Year == year)$Persons,
gastroRate = gastroRate)
out <- list(out)
names(out) <- .p$name
out
})
Sequel <- map(pathogens,function(.p){
map(.p[["sequelae"]],function(.s){
map(ageGroups,function(.a){
draw(.s, ndraws) * Initial[[.p$pathogen]][[.p$name]][[.a]]
})
})
})
#combine
imap(pathogens, ~c(Initial[[.y]], Sequel[[.y]]))
}
### CURRENTLY THE ESTIMATES COSTS FUNCTION PULLS ON INCIDENCE LIST AS A GLOBAL
### VARIABLE WITH NO REGARD FOR WHICH YEAR INCIDENCE LIST WAS CALCULATED FOR.
### I.E. YOU CAN CALCULATE INCIDENCE FOR YEAR 2019 THEN CALCULATE COSTS FOR YEAR
### 2020 WITHOUT GETTING AN ERROR. FIX BY MAKING INCIDENCE A LIST OF LISTS
### WITH AND ENTRY FOR EACH YEAR?
IncidenceList <- makeIncidenceList(2019,
pathogens = PathogenAssumptions,
ndraws = ndraws,
gastroRate = gastroRate)
makeIncidenceList <- function(year, pathogens, ndraws = 10^6, gastroRate){
ageGroups <- c("<5","5-64","65+")
names(ageGroups) <- ageGroups
Initial <- map(pathogens,
function(.p){
if(.p$caseMethod == "Notifications"){
ntfcs <- subset(NotificationsAgeGroup,Disease == .p$name & Year == year & AgeGroup %in% ageGroups)
if(nrow(ntfcs) == 0)stop('No notifications available for for year ', year, ', disease ', .p$name)
else if(nrow(ntfcs) > length(ageGroups))stop('More than one number found for notifications for year ', year, ', disease ', .p$name)
notifications <- as.list(ntfcs$Cases)
names(notifications) <- ntfcs$AgeGroup
} else notifications <- NULL
out <- estimateIncidence(.p,ndraws = ndraws, notifications = notifications,
population = subset(AusPopSingleYear, Year == year)$Persons,
gastroRate = gastroRate)
out <- list(out)
names(out) <- .p$name
out
})
Sequel <- map(pathogens,function(.p){
map(.p[["sequelae"]],function(.s){
map(ageGroups,function(.a){
draw(.s, ndraws) * Initial[[.p$pathogen]][[.p$name]][[.a]]
})
})
})
#combine
imap(pathogens, ~c(Initial[[.y]], Sequel[[.y]]))
}
# Draw from all distributions
ndraws <- 10^3
### CURRENTLY THE ESTIMATES COSTS FUNCTION PULLS ON INCIDENCE LIST AS A GLOBAL
### VARIABLE WITH NO REGARD FOR WHICH YEAR INCIDENCE LIST WAS CALCULATED FOR.
### I.E. YOU CAN CALCULATE INCIDENCE FOR YEAR 2019 THEN CALCULATE COSTS FOR YEAR
### 2020 WITHOUT GETTING AN ERROR. FIX BY MAKING INCIDENCE A LIST OF LISTS
### WITH AND ENTRY FOR EACH YEAR?
IncidenceList <- makeIncidenceList(2019,
pathogens = PathogenAssumptions,
ndraws = ndraws,
gastroRate = gastroRate)
SequelaeFractions <- calcSequelaeFractions(IncidenceList)
HospList <- makeHospList(2019,
IncidenceList,
pathogens = PathogenAssumptions,
ndraws = ndraws)
DeathList <- makeDeathList(2019,
pathogens = PathogenAssumptions,
ndraws = ndraws)
CostList <- makeCostList(2019, PathogenAssumptions, ndraws, discount = 0) # no discounting and assuming a 5 year duration of ongoing illness is equivalent to the cross-sectional approach if we assume that case numbers were the same over the past five years.
estimateTests <- function(disease, ageGroup, ndraws = 10^6, incidence){
estimateGeneric(c(disease[["tests"]][["AllAges"]], disease[["tests"]][[ageGroup]]),
ndraws = ndraws, incidence = incidence)
}
estimateIncidence <- function(disease, ndraws = 10^6,
gastroRate = NULL, notifications = NULL,
population = NULL){
#abbreviate
d <- disease
n <- ndraws
ageGroups = c("<5","5-64","65+")
names(ageGroups) <- ageGroups
if(d$caseMethod == 'Notifications' && is.null(notifications)) stop("Notification numbers must be supplied for estimates from notifiable diseases")
draws <- switch(d$caseMethod,
Notifications = draw(d$underreporting, n) * draw(d$domestic, n),
GastroFraction = draw(gastroRate, n) * draw(d$gastroFraction, n),
Seroprevalence = draw(d$FOI, n))
foodborne <- draw(d$foodborne, n)
if(!is.null(d$symptomatic)){
symptomatic <- draw(d$symptomatic, n)
}else{
symptomatic <- 1
}
map(ageGroups, function(.a){
minAge <- switch(.a, `<5` = 0, `5-64` = 5,`65+` = 65)
maxAge <-  switch(.a, `<5` = 5, `5-64` = 65,`65+` = 101)
if(d$caseMethod != "Notifications") population <- population[(minAge+1):maxAge]
incidence <- switch(d$caseMethod,
Notifications = notifications[[.a]] * draws * foodborne * symptomatic,
GastroFraction = sum(population) * draws * foodborne * symptomatic,
Seroprevalence = {
as.numeric(map(draws,~{
S <- exp(-.x * (minAge:maxAge))
sum(population * (S[1:(maxAge-minAge)] - S[1+(1:(maxAge-minAge))]))
})) * symptomatic * foodborne
})
incidence
})
}
CostList <- makeCostList(2019, PathogenAssumptions, ndraws, discount = 0) # no discounting and assuming a 5 year duration of ongoing illness is equivalent to the cross-sectional approach if we assume that case numbers were the same over the past five years.
ListeriaOutbreak.cases <- estimateIncidence(disease = ListeriaOutbreak, ndraws = ndraws, notifications = ListeriaOutbreak.notifications)
ListeriaOutbreak.notifications <- list(`<5` = 0, `5-64` = 22-10, `65+` = 10)
ListeriaOutbreak.cases <- estimateIncidence(disease = ListeriaOutbreak, ndraws = ndraws, notifications = ListeriaOutbreak.notifications)
ListeriaOutbreak <- PathogenAssumptions$`Listeria monocytogenes`
ListeriaOutbreak$domestic <- rdist("discrete", value = 1)
ageGroups <- c("<5","5-64","65+")
names(ageGroups) <- ageGroups
ListeriaOutbreak.notifications <- list(`<5` = 0, `5-64` = 22-10, `65+` = 10)
ListeriaOutbreak.cases <- estimateIncidence(disease = ListeriaOutbreak, ndraws = ndraws, notifications = ListeriaOutbreak.notifications)
ListeriaOutbreak.deaths <- list(`<5` = 1, `5-64` = 7, `65+` = 10)
ListeriaOutbreak.separations <- map(ageGroups,
~{HospList$`Listeria monocytogenes`$Listeriosis[[.x]]/
IncidenceList$`Listeria monocytogenes`$Listeriosis[[.x]] *
ListeriaOutbreak.notifications[[.x]]})
ListeriaOutbreak.separations
ListeriaOutbreak.cases <- estimateIncidence(disease = ListeriaOutbreak, ndraws = ndraws, notifications = ListeriaOutbreak.notifications)
ListeriaOutbreak.deaths <- list(`<5` = 1, `5-64` = 7, `65+` = 10)
ListeriaOutbreak.separations <- map(ageGroups,
~{HospList$`Listeria monocytogenes`$Listeriosis[[.x]]/
IncidenceList$`Listeria monocytogenes`$Listeriosis[[.x]] *
ListeriaOutbreak.cases[[.x]]})
ListeriaOutbreak.separations
ListeriaOutbreak.cases <- estimateIncidence(disease = ListeriaOutbreak, ndraws = ndraws, notifications = ListeriaOutbreak.notifications)
ListeriaOutbreak.deaths <- list(`<5` = 1, `5-64` = 7, `65+` = 10)
ListeriaOutbreak.separations <- map(ageGroups,
~{HospList$`Listeria monocytogenes`$Listeriosis[[.x]]/
IncidenceList$`Listeria monocytogenes`$Listeriosis[[.x]] *
ListeriaOutbreak.cases[[.x]]})
ListeriaOutbreakCost <- estimateCosts(ListeriaOutbreak,
ndraws = ndraws,
cases = ListeriaOutbreak.cases,
notifications = ListeriaOutbreak.notifications,
separations = ListeriaOutbreak.separations,
deaths = ListeriaOutbreak.deaths,
year = 2019, #Year is used to estimate LOS -- should there be an option for NA or ALL which uses all data available?
discount = 0) #We are not even using discounting any more so I might drop this argument all together?
ListeriaOutbreakCost <- estimateCosts(ListeriaOutbreak,
ndraws = ndraws,
cases = list(Listeriosis = ListeriaOutbreak.cases),
notifications = list(Listeriosis = ListeriaOutbreak.notifications),
separations = list(Listeriosis = ListeriaOutbreak.separations),
deaths = list(Listeriosis = ListeriaOutbreak.deaths),
year = 2019, #Year is used to estimate LOS -- should there be an option for NA or ALL which uses all data available?
discount = 0) #We are not even using discounting any more so I might drop this argument all together?
ListeriaOutbreakCost.Summaries <- summariseCostList(list(`Listeria monocytogenes` = SalmOutbreakCost))
summariseCostList <- function(list){
totals <- lapply(rapply(list, enquote, how="unlist"), eval) %>%
as.data.frame(check.names = F) %>%
mutate(Draw = row.names(.)) %>%
pivot_longer(-Draw, names_sep = "\\.",
names_to = c("Pathogen", "Disease","AgeGroup","CostItem")) %>%
bind_rows(.,
group_by(.,Draw, Pathogen, Disease,CostItem) %>%
summarise(value = sum(value)) %>%
mutate(AgeGroup = 'All Ages')) %>%
bind_rows(.,
group_by(.,Draw, Pathogen, AgeGroup,CostItem) %>%
summarise(value = sum(value)) %>%
mutate(Disease = 'All Diseases'))  #%>%
# bind_rows(.,
#           group_by(.,Draw, Disease, AgeGroup,CostItem) %>%
#             summarise(value = sum(value)) %>%
#             mutate(Pathogen = 'All Pathogens'))
Detailed <-  totals %>%
group_by(Pathogen, AgeGroup, Disease, CostItem) %>%
summarise(median = median(value),
`5%` = quantile(value, 0.05),
`95%` = quantile(value, 0.95))
DirectCat <- c('GPSpecialist','ED','Hospitalisation','Tests','Medications')
WTPCat <- c('WTP', 'WTPOngoing')
LostProdCat <- c("HumanCapital","FrictionHigh", "FrictionLow")
Categorised <- totals %>%
subset(CostItem %in% c("Deaths",LostProdCat, paste0("Total.",LostProdCat))) %>%
bind_rows(group_by(totals,Draw,Pathogen, AgeGroup, Disease) %>%
summarise(Direct = sum(value[CostItem %in% DirectCat]),
WTP = sum(value[CostItem %in% WTPCat])) %>%
pivot_longer(Direct:WTP,names_to = 'CostItem', values_to = 'value')) %>%
rename(CostCategory = CostItem) %>%
group_by(Pathogen, AgeGroup, Disease, CostCategory) %>%
summarise(median = median(value),
`5%` = quantile(value, 0.05),
`95%` = quantile(value, 0.95))
list(Categorised = Categorised, Detailed = Detailed)
}
ListeriaOutbreakCost.Summaries <- summariseCostList(list(`Listeria monocytogenes` = SalmOutbreakCost))
ListeriaOutbreakCost.Summaries <- summariseCostList(list(`Listeria monocytogenes` = ListeriaOutbreakCost))
ew(ListeriaOutbreakCost.Summa
View(ListeriaOutbreakCost.Summaries$Categorised)
View(ListeriaOutbreakCost.Summaries$Detailed)
View(ListeriaOutbreakCost.Summaries$Detailed)
ListeriaOutbreak.separations
map(ListeriaOutbreak.separations, mean)
Costs
EnteritidisOutbreak.notifications <- list(`<5` = 0, `5-64` = 235, `65+` = 10)
EnteritidisOutbreak.cases <- estimateIncidence(disease = EnteritidisOutbreak,
ndraws = ndraws,
notifications = EnteritidisOutbreak.notifications)
EnteritidisOutbreak <- PathogenAssumptions$`Non-typhoidal salmonella`
EnteritidisOutbreak$domestic <- rdist("discrete", value = 1)
EnteritidisOutbreak.notifications <- list(`<5` = 0, `5-64` = 235, `65+` = 10)
EnteritidisOutbreak.cases <- estimateIncidence(disease = EnteritidisOutbreak,
ndraws = ndraws,
notifications = EnteritidisOutbreak.notifications)
EnteritidisOutbreak.deaths <- list(`<5` = 0, `5-64` = 1, `65+` = 10)
EnteritidisOutbreak.cases
EnteritidisOutbreak.cases <- estimateIncidence(disease = EnteritidisOutbreak,
ndraws = ndraws,
notifications = EnteritidisOutbreak.notifications)
EnteritidisOutbreak.cases
EnteritidisOutbreakCost <- estimateCosts(EnteritidisOutbreak,
ndraws = ndraws,
cases = list(Salmonellosis = EnteritidisOutbreak.cases),
notifications = list(Salmonellosis = EnteritidisOutbreak.notifications),
separations = list(Salmonellosis = EnteritidisOutbreak.separations),
deaths = list(Salmonellosis = EnteritidisOutbreak.deaths),
year = 2019, #Year is used to estimate LOS -- should there be an option for NA or ALL which uses all data available?
discount = 0) #We are not even using discounting any more so I might drop this argument all together?
EnteritidisOutbreak.notifications <- list(`<5` = 0, `5-64` = 235, `65+` = 10)
EnteritidisOutbreak.cases <- estimateIncidence(disease = EnteritidisOutbreak,
ndraws = ndraws,
notifications = EnteritidisOutbreak.notifications)
EnteritidisOutbreak.deaths <- list(`<5` = 0, `5-64` = 1, `65+` = 10)
EnteritidisOutbreak.separations <- map(ageGroups,
~{HospList$`Non-typhoidal salmonella`$Salmonellosis[[.x]]/
IncidenceList$`Non-typhoidal salmonella`$Salmonellosis[[.x]] *
EnteritidisOutbreak.cases[[.x]]})
EnteritidisOutbreak.deaths <- list(`<5` = 0, `5-64` = 1, `65+` = 10)
EnteritidisOutbreak.separations <- map(ageGroups,
~{HospList$`Non-typhoidal salmonella`$Salmonellosis[[.x]]/
IncidenceList$`Non-typhoidal salmonella`$Salmonellosis[[.x]] *
EnteritidisOutbreak.cases[[.x]]})
EnteritidisOutbreak.separations
EnteritidisOutbreak.notifications <- list(`<5` = 0, `5-64` = 235, `65+` = 0)
EnteritidisOutbreak.cases <- estimateIncidence(disease = EnteritidisOutbreak,
ndraws = ndraws,
notifications = EnteritidisOutbreak.notifications)
EnteritidisOutbreak.deaths <- list(`<5` = 0, `5-64` = 1, `65+` = 0)
EnteritidisOutbreak.separations <- map(ageGroups,
~{HospList$`Non-typhoidal salmonella`$Salmonellosis[[.x]]/
IncidenceList$`Non-typhoidal salmonella`$Salmonellosis[[.x]] *
EnteritidisOutbreak.cases[[.x]]})
EnteritidisOutbreak.separations
EnteritidisOutbreak.notifications
EnteritidisOutbreak.cases
EnteritidisOutbreakCost <- estimateCosts(EnteritidisOutbreak,
ndraws = ndraws,
cases = list(Salmonellosis = EnteritidisOutbreak.cases),
notifications = list(Salmonellosis = EnteritidisOutbreak.notifications),
separations = list(Salmonellosis = EnteritidisOutbreak.separations),
deaths = list(Salmonellosis = EnteritidisOutbreak.deaths),
year = 2019, #Year is used to estimate LOS -- should there be an option for NA or ALL which uses all data available?
discount = 0) #We are not even using discounting any more so I might drop this argument all together?
estimateGeneric <- function(items, ndraws = 10^6, incidence){
if(class(items) != 'list') stop('items must be a list')
n <- ndraws
if(length(incidence) != 1 & length(incidence) != n){
print(incidence)
stop('The length of incidence should either be 1 or equal to ndraws')
}
map(items, ~{draw(.x, n) * incidence})
}
EnteritidisOutbreakCost.Summaries <- summariseCostList(list(`Salmonella Enteritidis` = EnteritidisOutbreakCost))
EnteritidisOutbreakCost <- estimateCosts(EnteritidisOutbreak,
ndraws = ndraws,
cases = list(Salmonellosis = EnteritidisOutbreak.cases),
notifications = list(Salmonellosis = EnteritidisOutbreak.notifications),
separations = list(Salmonellosis = EnteritidisOutbreak.separations),
deaths = list(Salmonellosis = EnteritidisOutbreak.deaths),
year = 2019, #Year is used to estimate LOS -- should there be an option for NA or ALL which uses all data available?
discount = 0) #We are not even using discounting any more so I might drop this argument all together?
map(NULL, mean)
estimateSequelae <- function(pathogen, initialCases){
ageGroups = c("<5","5-64","65+")
names(ageGroups) <- ageGroups
map(pathogen[["sequelae"]],function(.s){
map(ageGroups,function(.a){
draw(.s, ndraws) * initialCases[[.a]]
})
})
}
help(map)
makeIncidenceList <- function(year, pathogens, ndraws = 10^6, gastroRate){
ageGroups <- c("<5","5-64","65+")
names(ageGroups) <- ageGroups
Initial <- map(pathogens,
function(.p){
if(.p$caseMethod == "Notifications"){
ntfcs <- subset(NotificationsAgeGroup,Disease == .p$name & Year == year & AgeGroup %in% ageGroups)
if(nrow(ntfcs) == 0)stop('No notifications available for for year ', year, ', disease ', .p$name)
else if(nrow(ntfcs) > length(ageGroups))stop('More than one number found for notifications for year ', year, ', disease ', .p$name)
notifications <- as.list(ntfcs$Cases)
names(notifications) <- ntfcs$AgeGroup
} else notifications <- NULL
out <- estimateIncidence(.p,ndraws = ndraws, notifications = notifications,
population = subset(AusPopSingleYear, Year == year)$Persons,
gastroRate = gastroRate)
out <- list(out)
names(out) <- .p$name
out
})
Sequel <- map(pathogens, estimateSequelae, initialCases = Initial[[.p$pathogen]][[.p$name]])
#combine
imap(pathogens, ~c(Initial[[.y]], Sequel[[.y]]))
}
### CURRENTLY THE ESTIMATES COSTS FUNCTION PULLS ON INCIDENCE LIST AS A GLOBAL
### VARIABLE WITH NO REGARD FOR WHICH YEAR INCIDENCE LIST WAS CALCULATED FOR.
### I.E. YOU CAN CALCULATE INCIDENCE FOR YEAR 2019 THEN CALCULATE COSTS FOR YEAR
### 2020 WITHOUT GETTING AN ERROR. FIX BY MAKING INCIDENCE A LIST OF LISTS
### WITH AND ENTRY FOR EACH YEAR?
IncidenceList <- makeIncidenceList(2019,
pathogens = PathogenAssumptions,
ndraws = ndraws,
gastroRate = gastroRate)
makeIncidenceList <- function(year, pathogens, ndraws = 10^6, gastroRate){
ageGroups <- c("<5","5-64","65+")
names(ageGroups) <- ageGroups
Initial <- map(pathogens,
function(.p){
if(.p$caseMethod == "Notifications"){
ntfcs <- subset(NotificationsAgeGroup,Disease == .p$name & Year == year & AgeGroup %in% ageGroups)
if(nrow(ntfcs) == 0)stop('No notifications available for for year ', year, ', disease ', .p$name)
else if(nrow(ntfcs) > length(ageGroups))stop('More than one number found for notifications for year ', year, ', disease ', .p$name)
notifications <- as.list(ntfcs$Cases)
names(notifications) <- ntfcs$AgeGroup
} else notifications <- NULL
out <- estimateIncidence(.p,ndraws = ndraws, notifications = notifications,
population = subset(AusPopSingleYear, Year == year)$Persons,
gastroRate = gastroRate)
out <- list(out)
names(out) <- .p$name
out
})
Sequel <- map(pathogens,
function(.p){estimateSequelae(.p,Initial[[.p$pathogen]][[.p$name]])})
#combine
imap(pathogens, ~c(Initial[[.y]], Sequel[[.y]]))
}
### CURRENTLY THE ESTIMATES COSTS FUNCTION PULLS ON INCIDENCE LIST AS A GLOBAL
### VARIABLE WITH NO REGARD FOR WHICH YEAR INCIDENCE LIST WAS CALCULATED FOR.
### I.E. YOU CAN CALCULATE INCIDENCE FOR YEAR 2019 THEN CALCULATE COSTS FOR YEAR
### 2020 WITHOUT GETTING AN ERROR. FIX BY MAKING INCIDENCE A LIST OF LISTS
### WITH AND ENTRY FOR EACH YEAR?
IncidenceList <- makeIncidenceList(2019,
pathogens = PathogenAssumptions,
ndraws = ndraws,
gastroRate = gastroRate)
IncidenceList
summariseList <- function(list){
lapply(rapply(list, enquote, how="unlist"), eval) %>%
as.data.frame(check.names = F) %>%
mutate(Draw = row.names(.)) %>%
pivot_longer(-Draw, names_sep = "\\.",
names_to = c("Pathogen", "Disease","AgeGroup")) %>%
bind_rows(.,
group_by(.,Draw, Pathogen, Disease) %>%
summarise(value = sum(value)) %>%
mutate(AgeGroup = 'All Ages')) %>%
bind_rows(.,
group_by(.,Draw, Pathogen, AgeGroup) %>%
summarise(value = sum(value)) %>%
mutate(Disease = 'All Diseases')) %>%
# bind_rows(.,
#           group_by(.,Draw, AgeGroup, Disease) %>%
#             summarise(value = sum(value)) %>%
#             mutate(Pathogen = 'All Pathogens')) %>%
group_by(Pathogen, Disease, AgeGroup) %>%
summarise(median = median(value),
`5%` = quantile(value, 0.05),
`95%` = quantile(value, 0.95))
}
IncidenceTable <- summariseList(IncidenceList)
IncidenceTable
View(IncidenceTable)
